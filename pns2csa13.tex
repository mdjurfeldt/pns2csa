
\documentclass{frontiersSCNS} % for Science articles

\usepackage{url}
\usepackage[modulo]{lineno}
\linenumbers

%----------------------------------------------------------------------
% Own stuff
\newcommand{\INLINEFIGS}{} % comment out for Frontiers submission
%\usepackage{endfloat}
\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage{xspace}
\usepackage{textcomp}
\newcommand{\permil}{\,\textperthousand\xspace}
\newcommand{\tbw}[1]{{\bf\parindent0pt\color{red}#1}}
\usepackage{minted}
\newminted{python}{showspaces=false,
  showtabs=false,
%  linenos=true,
  fontsize=\tiny,
  mathescape=true,
  frame=leftline,
  framerule=0pt,
  framesep=0mm}
\ifdefined\INLINEFIGS
\newcommand{\Figure}[2]{Figure~\ref{#2}}
\else
\newcommand{\Figure}[2]{Figure~#1}
\fi
%----------------------------------------------------------------------

\copyrightyear{}
\pubyear{}

\def\journal{Neuroinformatics}%%% write here for which journal %%%
\def\DOI{}
\def\articleType{Research Article}
\def\keyFont{\fontsize{8}{11}\helveticabold }
\def\firstAuthorLast{Djurfeldt {et~al.}}
\def\Authors{Mikael Djurfeldt\,$^{1,2,*}$, Andrew P. Davison\,$^{3}$,
 and Jochen M. Eppler\,$^4$}
% Affiliations should be keyed to the author's name with superscript
% numbers and be listed as follows: Laboratory, Institute, Department,
% Organization, City, State abbreviation (USA, Canada, Australia), and
% Country (without detailed address information such as city zip codes
% or street names).  If one of the authors has a change of address,
% list the new address below the correspondence details using a
% superscript symbol and use the same symbol to indicate the author in
% the author list.
\def\Address{$^{1}$PDC Center for High-Performance Computing, KTH
  Royal Institute of Technology, Stockholm, Sweden\\
  $^{2}$International Neuroinformatics Coordinating Facility (INCF),
  Stockholm, Sweden\\
  $^{3}$Unité de Neurosciences, Information et Complexité (UNIC),
  CNRS, Gif sur Yvette, France\\
  $^{4}$Institute of Neuroscience and Medicine (INM-6) and Institute
  for Advanced Simulation (IAS-6), Jülich Research Centre and
  JARA, Jülich, Germany}
% The Corresponding Author should be marked with an asterisk Provide
% the exact contact address (this time including street name and city
% zip code) and email of the corresponding author
\def\corrAuthor{Mikael Djurfeldt} \def\corrAddress{International
  Neuroinformatics Coordinating Facility (INCF), Nobels väg 15 A,
  Stockholm, SE-17177, Sweden} \def\corrEmail{djurfeldt@incf.org}

% \color{FrontiersColor} Is the color used in the Journal name, in the
% title, and the names of the sections

\begin{document}
\onecolumn
\firstpage{1}

\title[CSA in NEST and PyNN]{Modeling connectivity: Connection-set
 Algebra in NEST and PyNN}
\author[\firstAuthorLast ]{\Authors}
\address{}
\correspondance{}
\extraAuth{}% If there are more than 1 additional author, comment this
%line and uncomment the next one
%\extraAuth{corresponding Author2 \\ Laboratory X2, Institute X2,
%Department X2, Organization X2, Street X2, City X2 , State XX2 (only
%USA, Canada and Australia), Zip Code2, X2 Country X2,
%email2@uni2.edu}
\topic{Python in Neuroscience II}

\maketitle
\begin{abstract} % maximum 2000 characters including spaces

Most neuronal network simulators provide simulator-specific methods
for specifying connectivity. Thus, modelers need to learn the ways of
each simulator and connectivity descriptions are not easily moved
between them.  To improve this situation, several universal
description languages for neuronal network models (e.g. PyNN, NeuroML
and NineML) have been developed.

There is commonly a choice between explicitly specifying individual
connections or selecting one of a predefined set of connection
primitives. Such primitives are usually well suited for building
random balanced networks, synfire chains and recurrent networks
without much structure, however they often either lack the required
expressiveness or their implementations lack the required
computational efficiency to specify the connectivity of complex
hierarchical network models.

The connection-set algebra is a formalism for specifying the
connectivity of neuronal network models. CSA provides operators to
combine simpler connectivities into more complex ones and also
provides parameterization of such sets. The CSA is expressive enough
to describe a wide range of connectivities and can serve as a concise
notation for network structure in scientific writing as well as in
model description code for neural simulations. CSA implementations
allow for scalable and efficient representation of connectivity in
parallel neuronal network simulators.

Here, we describe the use of CSA and how it is coupled to the neural
simulation tool NEST through the new \verb|ConnectionGenerator|
interface provided by the \verb|libneurosim| library. We demonstrate
how CSA can be used for the specification of connectivity in the
simulator-independent neural specification language PyNN and how using
CSA as a high-level representation of connectivity patterns avoids
performance penalties and results in good scalability when transferred
to the simulator.

\tiny
 \keyFont{ \section{Keywords:} model description, connectivity,
 neural simulation, Python, large-scale modeling } %All article
 %types: you may provide up to 8 keywords; at least 5 are mandatory.
\end{abstract}

\section{Introduction}

The central nervous systems of vertebrates and many invertebrates have
complex patterns of connections.  In developing neuronal network
models of such systems, there are two main tasks related to connection
patterns.  The first is to express the connectivity in a
machine-readable format, e.g. in code or in a configuration file.  The
second is to explain the connectivity unambiguously in prose in an
article or book, so that the model can be understood and reproduced by
someone else \citep{nordlie-2009_e1000456}.

For expressing connectivity in code, three methods are commonly used:
(i) procedural code written by the modeller, using low-level
operations such as connecting pairs of neurons or connecting a single
neuron to a group; (ii) a library of pre-defined, parameterized
connection routines; (iii) an explicit list of connections.  Each of
these have their limitations.  Procedural code and libraries limit the
connectivity descriptions to a single language and often a single
simulator, making it hard to port models from one simulator to
another.  Procedural code takes time to write, and will have more bugs
than a library, since library code is likely to be more thoroughly
tested and reused.  On the other hand, the connectivity patterns
available from a library are inevitably more limited than those that
can be achieved with user-written code.  Using an explicit list of
connections is largely independent of a particular simulator or
programming language, but may cause problems of storage and
input/output efficiency, and does not enable conceptual descriptions
of connectivity.  All of these methods make it difficult to explain
the connectivity in a scientific text. [ref Crook et al 2013 somewhere
  in here?]

These problems can be reduced or avoided by using a general purpose
connection-generating software library such as the Connection-set
Algebra \citep[CSA;][]{djurfeldt12} or the NineML graph library
\citep{raikov10}.  Such libraries allow simulator-independent
specification of connectivity and enable high-level, declarative
descriptions which do not constrain how the connectivity should be
realized in code and hence give scope for optimization and
parallelization within the simulator software.  The CSA in addition
supports succinct, unambiguous descriptions of connectivity in text,
using a mathematical notation.

The adoption of new, simulator-independent methods for expressing
connectivity, such as CSA, is hindered by the effort needed to add
support for a given connection-generating library to a simulator.
This effort must, in general, be repeated for each simulator that
wishes to support the library.  The exception to this is if using a
simulator-independent modelling interface such as PyNN
\citep[\url{http://www.neuralensemble.org/PyNN};][]{Davison09}, which
supports multiple simulators; PyNN however is written in Python, which
means that processing the CSA description will be slower than if using
C/C++ (the languages in which many simulators are written).
Furthermore, whether using a simulator-independent interface or not, a
new programming effort is needed if another new method for expressing
connectivity is developed.

To minimize the effort required of simulator software developers, and
allow modellers to flexibly choose among simulators and libraries
which generate connectivity, we have developed a generic
\emph{connection generator} interface, which enables the use of CSA
and similar libraries in different neuronal simulators.  The interface
makes both the simulator and the connection-generating library
replaceable and therefore gives maximum flexibility to the modeller.

In this article we first describe the connection generator interface.
As an example of a connection generating library, we then give a brief
overview of CSA and of different software libraries that support using
CSA in Python and C++ code. We show how the connection generator
interface has been integrated in the NEST simulator
\citep[\url{http://www.nest-initiative.org};][]{Gewaltig_07_11204},
enabling the use of connection libraries such as CSA, before
describing its use from higher software layers, such as the PyNN
framework.  Finally, we provide benchmarks for different use case
scenarios of the interface.

%----------------------------------------------------------------------

\section{The Connection Generator API}

To allow users to flexibly choose among simulators and libraries which
generate connectivity, we developed an interface that abstracts the
simulator and the connection generating library from each other,
making both the simulator and the connectivity description library
replaceable.

\ifdefined\INLINEFIGS
\begin{figure}[ht]
\centering
\includegraphics[scale=.8]{figures/block_diagram_conngen.pdf}
\caption{Block diagram of the connection generator interface and the
  components involved. The central component is the
  \texttt{ConnectionGenerator} class itself. It can connect to different
  simulators (e.g. NEST) and to different connection generating
  libraries (e.g. CSA). In this example, Python is used as scripting
  language for both simulator and connection generating
  library.}\label{fig:block_diagram_conngen}
\end{figure}
\fi

A connection generating library, such as
\verb|csa| or \verb|libcsa| of Section~\ref{sec:impl}, is used to
create an object representing network connectivity.  In the case of a
CSA library, this object is a connection-set, but it could also be a
graph made through graph primitives. The \verb|ConnectionGenerator| interface
provides a C++ level interface to such objects which allows software
external to the connection generating library to efficiently iterate
through connections represented by the object.  In the example shown
in \Figure{2}{fig:block_diagram_conngen}, the \verb|ConnectionGenerator|
interface is used to combine a Python scripted simulator with a Python
scripted connection generating library. A connection generating object
is assembled at the Python level.  If \verb|libcsa| is used, the
resulting object will be a C++ object with a Python wrapper. (See
lower two boxes to the right in the figure.) The object is used by a
C++ simulator kernel (lower box to the left) to specify network
connectivity. By providing connection generating software, with
Connection Generator API, as dynamically linked libraries, multiple
such libraries can be loaded into the Python runtime environment and
even used simultaneously without a need to recompile the simulator.

\subsection{The interface}\label{sec:cgint}

In neuronal network simulations, we often want to specify a projection
between a source population of neurons $P_s$ to a target population
$P_t$.  A projection consists of many individual connections between
the source and target populations.  In nature, one such connection
corresponds to an axon forming a synaptic contact on the
spine/dendrite of a receiving neuron.  A connection generator object
is modeled on concept of a projection.  The source and target
populations are each enumerated using integer indices.  These indices
are then used to specify source and target neuron identity and
constitutes an abstraction barrier between the elements of a
population and the connection generator.  This allows the elements to
be other types of objects than neurons, for example dendritic
sites.

The principle of operation of the \verb|ConnectionGenerator| interface
is an iteration over all connections represented by the object.  A
simulator, or other software using a connection generator, repeatedly
calls a function \verb|next()| until boolean \verb|false| is
returned. Connections are represented by source and target index of
connection, together with zero or more connection parameters.  The
number of parameters is called the \emph{arity} of the connection
generator.  The interface is designed as an abstract base class in C++
and consists of the following virtual functions:

\begin{unlist}
\item[\tt int arity()]: Return the number of per-connection values
  associated with this generator. Values can be parameters like
  weight, delay, time constants, or others.
\item[\tt int size()]: Return the number of connections represented by
  this generator.
\item[\tt void setMask(Mask\& mask)]: Inform the generator about which
  source and target indices are available. A
  \verb|ConnectionGenerator| mask represents the available nodes in
  the network for which to create connections.
\item[\tt void setMask(std::vector$<$Mask$>$\& masks, int local)]:
  This version of \texttt{setMask} is used by parallel simulators and
  informs the connection generator on the \verb|local| rank about the
  masks of all ranks. Different ranks usually have different masks
  since they are responsible for different subsets of the connections
  of the network. Some connection generators can use such information
  to avoid the need for communication with other ranks.
\item[\tt void start()]: Start an iteration. This function must be called
  before the first call to \verb|next()|.
\item[\tt bool next(int\& source, int\& target, double* value)]:
  Advance to the next connection or return false, if no more
  connections are available from the connection generator. Source and
  target indices of the connection as well as associated parameters
  are written into \verb|source|, \verb|target| and the array pointed
  to by \verb|value|, respectively. The order of iteration is
  according to increasing index, with all sources iterated over per
  target.
\end{unlist}

\subsection{libneurosim}\label{sec:libneurosim}
If the C++ header file for the \verb|ConnectionGenerator| interface
definition and its supporting code is put
in the simulator or connection generating library source trees, it
will be duplicated over simulators or libraries.  As new versions of
the interface are developed, the situation will quickly become
unmanageable.  In fact, the \verb|ConnectionGenerator| interface is
unusual in that it is a symmetric abstraction barrier: it both allows
a given simulator to use any library supporting the API \emph{and}
allows the same library to be used from any simulator supporting the
API.

In order to create a space in which to put interfaces and other code
of generic use for neuronal network simulation software, we have
developed the neurosim library
(\url{http://software.incf.org/software/libneurosim}).  More
precisely, libneurosim is a software package which currently consists
of two main component libraries: \verb|libneurosim|, providing C++
level support code and \verb|libpyneurosim|, providing Python support
code.

\verb|Libneurosim| provides the \verb|ConnectionGenerator| interface
(\Figure{2}{fig:block_diagram_conngen}, bottom). It also contains a
registry for XML parser functions.  Different types of connection
generators can be described by different XML-based languages.  For
example, the \verb|csa| library can serialize connection-set
expressions using a MathML-based language.  A connection generating
library may provide a parser for one or more such languages.
Conversely, the same XML-based language might be used by one or more
connection generating libraries.  The XML parser registry maps XML
tags identifying specific languages to specific connection libraries.
The interface to the registry consists of three static methods in the
\verb|ConnectionGenerator| interface:

\begin{unlist}
\item[\tt void selectCGImplementation (std::string tag, std::string
  library)]:\\ Associate the parent node tag \verb|tag| with the library
  \verb|library|.  The library named \verb|library| will be
  dynamically loaded and will invoke the \verb|libneurosim| function
  \verb|registerConnectionGeneratorLibrary| to register its XML
  parser.
\item[\tt ConnectionGenerator* fromXML (std::string xml)]: Parse the
  XML representation \verb|xml| of a connection generator and return
  it. The function dispatches to parsers of different libraries
  depending on previous calls to \verb|selectCGImplementation|.
\item[\tt ConnectionGenerator* fromXMLFile (std::string fname)]: Same
  as previous function, but read the XML stream from the file with
  pathname \verb|fname|.
\end{unlist}

\verb|libpyneurosim| currently contains generic support for
registering new Python connection generator types and unwrapping
instances of such objects:

\begin{unlist}
\item[\tt void registerConnectionGeneratorType (CheckFuncT,
  UnpackFuncT)]: Register a new type checking and unwrapping
  function.
\item[\tt isConnectionGenerator (PyObject* pObj)]: Check if
  \verb|pObj| is a known connection generator type (as identified by
  previously registered checking functions).
\item[\tt ConnectionGenerator* unpackConnectionGenerator (PyObject*
  pObj)]: Unwrap the connection generator in \verb|pObj| and return
  it.
\end{unlist}

\section{The Connection-set Algebra}\label{sec:csa}

The connection-set algebra is a formalism
for network connectivity which can be used both when describing a
network to a fellow researcher and when implementing a model for a
simulator.  It is currently focused on connectivity which has a
constructive or statistical element such that it can be specified by
an algorithm, but it can also be used when all network connections are
given or in cases where only some elements of the connectivity are
explicitly specified. The distinguishing aspects of CSA are:
\begin{itemize}
\item It is abstract. CSA deals with sets of \emph{connections}. A
  connection is an edge in a graph, with associated
  parameters. There is a clean separation between CSA and other
  aspects of model or simulator infrastructure.
\item A connection-set can represent a \emph{type} of
  connectivity---a connectivity pattern---in addition to the connectivity
  of a specific network.
\item It is an algebra: There are pre-existing connection-sets and
  operators to define new connection-sets in terms of existing ones.
\item It enables a succinct and precise description and definition of
  connectivity in terms of such algebraic expressions.
\item There are ways to implement CSA on a computer which are both
  efficient and scalable on a parallel computer.
\end{itemize}


\subsection{Connection-sets}

Given source and target populations $P_s$ and $P_t$, a CSA
connection-set is defined as the set of connections between $P_s$ and
$P_t$ along with zero or more per-connection parameters such as weight
or delay. As for a connection generator, elements of populations are
enumerated using non-negative integers. Thus, a population $P$ is
represented by an index set $\mathcal{I}$. One connection from $P_s$
to $P_t$ is represented by the pair $(i, j)$, where $i \in
\mathcal{I}_s, j \in \mathcal{I}_t$.  Such indices are similar to the
GIDs (Global IDentifiers) of the NEURON and NEST simulators but
normally start at 0 and run consecutively for each population.
Introducing this abstraction, in the form of a mapping from objects in
the simulation domain to integers, gives at least two major
advantages: 1. The CSA does not need to care about the nature of the
objects in $P$---they could just as well be synaptic boutons as
neurons.  2. The index set $\mathcal{I}$ can be chosen to be infinite.
The gain of this will be demonstrated in Section~\ref{sec:structure}.

\ifdefined\INLINEFIGS
\begin{figure}[ht]
\centering
\includegraphics[scale=.7]{figures/csa-pane.pdf}
\caption{
  \textbf{A} The mask $\overline{M} =
  \{(0,1), (1,1), (1,2), (3,2), (2,3), (0,4)\}$ shown as a connection
  matrix. Grey squares represent existing connections.
  \textbf{B} Network connectivity when the mask in A is applied to
  source population $P_s$ and target population
  $P_t$.
  \textbf{C} The one-to-one mask $\bar{\delta}$. The mask is infinite,
  but finite portions can be cut out when applied to finite source and
  target populations. This is illustrated by the solid square for
  source and target size 7. When source and target population is the
  same, $\bar{\delta}$ represents self-connections.
  \textbf{D} The mask $\bar{\rho}(0.5) - \bar{\delta} =$ random
  connectivity without self-connections.
}\label{fig:csa} 
\end{figure}
\fi

A connection-set with zero parameters is called a \emph{mask}. A mask
tells which connections exist.  In the example of the mask
$\overline{M} = \{(0,1), (1,1), (1,2), (3,2), (2,3), (0,4)\}$ it can
be regarded either as a connection matrix (see \Figure{1}{fig:csa}A)
or as a boolean indicator function:
\begin{equation}
\overline{M} : \mathcal{I}_s \times \mathcal{I}_t \rightarrow \{ \mathcal{F},
\mathcal{T} \}
\end{equation}
In the example $\overline{M}(0,0) = \mathcal{F}$ while
$\overline{M}(1,1) = \mathcal{T}$. If the mask is combined with a
source population $P_s$ and a target population $P_t$, the result is
the network $(P_s, P_t, \overline{M})$ shown in \Figure{1}{fig:csa}B.

In CSA, connections can be parameterized through functions mapping
connections to values:
\begin{equation}
V : \mathcal{I}_s \times \mathcal{I}_t \rightarrow \mathcal{V}
\end{equation}
where $\mathcal{V}$ is some codomain. In \citet{djurfeldt12}, such a
function is called a \emph{value set}. An example of a value set is
distance dependent delays with added noise sampled from a clipped
random normal distribution. Value sets are typically used to assign a
weight or delay to connections.

A CSA \emph{connection-set}, $C$, is a tuple of a mask and zero or
more value sets:
\begin{equation}
C = (\overline{M}, V_0, V_1, ...)
\end{equation}
The number of value sets of a connection-set is called its
\emph{arity}. A connection-set with arity 0 is for all purposes
equivalent to a mask and the two can be used interchangeably.

\subsection{An algebra for connectivity structure}\label{sec:structure}

In CSA, the concepts defined in the previous section have been
developed into a formalism for describing connectivity structure.
Assume that a mask is applied to a single population such that $P_s =
P_t = P$ and that we are interested in describing self-connections,
i.e. every neuron in $P$ should be connected to itself.  If the size
of $P$ is 4, the mask $\{(0, 0), (1, 1), (2, 2), (3, 3)\}$ could be
used.  If the size is 2, the mask $\{(0, 0), (1, 1)\}$ would be
appropriate. Such masks do not only contain information about
connectivity structure but also about population size. We can
generalize by stripping off the population size information and
allowing the index set $\mathcal{I}$ and mask to be infinite, defining
the one-to-one mask $\bar{\delta}$:
\begin{equation}
  \bar{\delta}(i, j) =
      \begin{cases}
        \mathcal{T}& \text{if $i = j$},\\
        \mathcal{F}& \text{otherwise}.
      \end{cases}
      \quad i, j \in \mathcal{I} = \mathbb{N}_0
\end{equation}
Now $\bar{\delta}$ only encapsulates the concept of self- or
one-to-one connectivity structure (depending on whether the source and
target populations are the same or different), i.e. we can describe a
type of connectivity independently of any specific network.  Finite
portions can be cut out of such infinite connection-sets when applied
to finite populations (see \Figure{1}{fig:csa}C).

CSA provides a set of elementary connection-sets such as
$\bar{\delta}$. Another example is the random mask $\bar{\rho}$, a
parameterized connection-set, or, more strictly, a mask-valued
function $\bar{\rho}(p)$ where the parameter $p$ is the probability
that a given connection $(i, j)$ exists.  That is, for each
combination of pre- and post-synaptic neurons, a Bernoulli trial
determines whether they are connected.
\begin{equation}
  \bar{\rho} (p) (i, j) =
  \begin{cases}
    \mathcal{T}& \text{with probability $p$},\\
    \mathcal{F}& \text{otherwise}.
  \end{cases}
  \quad i, j \in \mathbb{N}_0
\end{equation}
By using CSA \emph{operators} such as intersection ($\cap$), union
($\cup$) and set difference ($-$), connection-sets can be combined into
expressions. For example, the idea of ``random Erd\H{o}s-R\'enyi
connectivity without self-connections'' can be represented by the CSA
expression $\bar{\rho}(p) - \bar{\delta}$ (see Figure
\ref{fig:csa}D). A mask representing all possible connections between
two finite populations can be formed by taking the Cartesian product
of their index sets, $\mathcal{I}_s \times
\mathcal{I}_t$. Intersecting with this mask can turn an infinite
connection-set, representing connectivity structure, into a connection
matrix between the populations. For example, the finite part of the
matrix in \Figure{1}{fig:csa}C is $\{0..6\} \times \{0..6\} \cap
\bar{\delta}$. For a more in-depth description of the CSA and
principles of implementation, see \citet{djurfeldt12}.

%  \textbf{Figure 1.}{CSA Connection Matrix.}\label{fig:01}
%\subsection{Examples}
%  \textbf{Figure 2.}{An example of using CSA.}\label{fig:02}
%\subsection{Parallelization}
\subsection{Implementations}\label{sec:impl}

There currently exist three implementations of CSA.  The original
implementation is written in C++ and is part of the SPLIT simulation
library \citep{djurfeldt05}.  It was used to specify the connectivity
of the KTH cortex model \citep{djurfeldt08}---a model with three
hierarchical levels of structure.  The second implementation is
written in Python and is available as the Python library \verb|csa|.
Here, the purposes were 1. to get an easily usable and extensible
demonstration of CSA and 2. to experiment with new ways to implement
CSA. This implementation has been released as free software under the
GPL and is available at the INCF software center
(\url{http://software.incf.org/software/csa}). A third implementation
in C++, \verb|libcsa|, is currently under development and will also be
released under the GPL. It provides Python bindings such that CSA
objects can be formed by Python level expressions with similar syntax
as used with the \verb|csa| library. For further information about
this syntax, the reader is referred to the tutorial in the \verb|csa|
package. The benchmarks in this article were performed using the
latter two implementations in Python and C++, \verb|csa| and
\verb|libcsa|.

% MDJ: I think I'll keep it like that. This paper is so complex
% conceptually anyway. We don't need to desribe everything!

%\subsubsection{Masks}
%\subsection{Python wrapper}
%\subsection{Serialization/deserialization}

%----------------------------------------------------------------------

\section{Using connection generators in NEST}\label{sec:conn_gen_nest}

NEST is a simulator for large networks of point neurons or neuron
models with few electrical compartments
\citep[\url{http://www.nest-initiative.org};][]{Gewaltig_07_11204}. It
is suited for a broad range of neuronal network modeling approaches
and runs on a large variety of computer architectures. NEST is
parallelized using OpenMP \citep{OpenMPSpec} and MPI
\citep{MPIForum94} and scales well on large clusters of multi-core
processors and supercomputers \citep{Helias12_26}.

The network description is a script, written either in SLI, NEST's
built-in simulation language, or in Python, using the Python interface
to NEST \citep[PyNEST;][]{Eppler09_12}. The following description uses
the PyNEST syntax if not noted otherwise.

To build a network in NEST,
the user first creates the neurons of the network and devices for
stimulation and measurement using the \verb|Create()| function and
then connects the elements with each other. NEST provides two basic
ways for creating connectivity.

\subsubsection{Native connection functions:}

The most basic connect function, \verb|Connect()|, takes a list of
pre-synaptic neurons (or devices) and a list of the same amount of
post-synaptic neurons (or devices) and connects them in a one-to-one
fashion. Because of the function call overhead, this function is not
very efficient to use when creating large networks.

For such cases, the connection functions \verb|ConvergentConnect()|
and \verb|DivergentConnect()| can be used to create multiple
connections with a single call. In addition, random variants for both
functions exist to support the user in creating networks on the basis
of knowledge of connectivity statistics. However, random connection
parameters (e.g. \emph{weight} or \emph{delay}) need to be specifiec
by user code and supplied to NEST after the creation of connections.

\subsubsection{Topology module:}

To ease the creation of networks with topological relations between
the neurons and organizations of neurons into layers and areas, NEST
provides a Topology module \citep{Plesser_13}. It supports the user in
connecting neurons and randomly initializing synapse parameters based
on geometry or topological relationships in the network.

The design of the novel interface for using connection generators from
NEST is explained in Section~\ref{sec:conn_gen_nest}. In Section
\ref{sec:benchmarks}, we provide benchmarks for different use case
scenarios of the interface. A comparison of the performance of the
novel CSA interface, the native connection routines and the Topology
module of NEST is subject to further work.


As detailed in Section~\ref{sec:nest}, NEST has several methods for
connecting neurons into a network built-in. However, while the native
routines scale very well \citep{Helias12_26}, they are only suitable
for creating simple patterns such as convergent/divergent connectivity
without using them in an iterative manner. On the other hand, the
topology module \citep{Plesser_13} allows to form more complex
structures, but requires neurons to be organized in a layers. This has
some overhead, which is also reflected in the performance and scaling.

To support the Connection Generator interface in NEST and thus make
more connection generating libraries available to the user, we created
the \verb|ConnectionGeneratorModule|. It is implemented as a plugin
for NEST which extends both user interfaces (SLI and PyNEST) and
builds on \verb|libneurosim| (see Section~\label{sec:libneurosim}).

All elements (neurons or devices) in NEST are identified uniquely by
an integer number, their global id (\emph{GID}). As all existing
connection routines in NEST work either on single GIDs or on lists of
GIDs, we decided to also use this convention for the Connection
Generator interface in NEST, although that uses indices running from
zero. Our new Connection Generator interface for NEST contains the
following functions:

\begin{unlist}
\item[\tt CGConnect], which takes a connection generator \emph{cg},
  lists of GIDs for \emph{pre}- and a \emph{post}-synaptic
  populations, and a \emph{param\_map}. It creates the connections
  between neurons in \emph{pre}- and a \emph{post} as prescribed by
  the rules in \emph{cg}. The parameter map \emph{param\_map} maps
  parameter names (e.g. \emph{weight}, \emph{delay}) to their index
  for the parameter value vector created by the call to \verb|next()|
  in the \verb|ConnectionGenerator| interface (see Section
  \ref{sec:cgint}). The basic implementation of \verb|CGConnect| is
  explained below.
\item[\tt CGParse], which takes a serialized version of a connection
  generator in the string \emph{xml} and returns the corresponding
  object. A special use of this function exists on supercomputers,
  where Python is often not available on the compute nodes, or where
  the memory and performance penalty would not be acceptable and a
  pure SLI-based solution is preferable.
\item[\tt CGParseFile], which takes a file name \emph{fname} and parses
  the serialized version of a connection generator contained therein.
\item[\tt CGSelectImplementation], which takes an XML tag \emph{tag}
  representing the parent node of a serialized connection generator
  and the name of a library \emph{library} to provide a parser for
  such an XML file. This information determines which library should
  carry out the parsing for \verb|CGParse|.
\end{unlist}

When PyNEST is used, the connection generator can be created by the
user in Python using the Python wrapper of \verb|libcsa|. In the call
to \verb|CGConnect()|, a pointer to the underlying
\verb|ConnectionGenerator| object in C++ is converted into a SLI
Datum, which can be shipped into NEST's simulation kernel and handled
there using the C++ interface to the connection generator. In SLI,
there is no direct way of creating a connection generator. However,
the SLI functions \verb|CGParse| and \verb|CGParseFile| can read a
serialized version of a connection generator either from a string or
from an XML file and reinstantiate the object, which can then be given
to SLI's version of the \verb|CGConnect| function.

\ifdefined\INLINEFIGS
\begin{figure}[ht]
\centering
\includegraphics[scale=.8]{figures/sequence_diagram_nest.pdf}
\caption{Sequence diagram showing the function calls during the use of
  the \texttt{ConnectionGenerator} interface in NEST. The user first creates a
  \texttt{ConnectionGenerator} object \emph{cg}. She then calls
  PyNEST's \texttt{CGConnect()} function. \textcircled{\footnotesize
    1} The function \texttt{cg\_get\_ranges()} returns all contiguous
  ranges of global IDs (GIDs) in the given list as a vector of closed
  intervals, still using the GID representation.
  \textcircled{\footnotesize 2} At this point in time, the
  ConnectionGeneratorModule needs to translate the GIDs to CSA
  indices, which run from 0 and enumerate the elements of the given
  \emph{pre}- and \emph{post}-synaptic populations. The result of the
  translation (\emph{pre\_mask} and \emph{post\_mask}) is used to set
  the masks on \emph{cg}. \textcircled{\footnotesize 3} The NEST
  kernel iterates the connection generator by calling \texttt{next()}
  until there are no more connections. For each received connection,
  it creates the connection by calling \texttt{Network::connect()}. If
  a non-empty \emph{param\_map} was given to \texttt{CGConnect}, the
  connection's weight and delay are taken from the value-set in
  \emph{cg}.}\label{fig:sequence_diagram_nest}
\end{figure}
\fi

\Figure{3}{fig:sequence_diagram_nest} shows the different entities in
NEST involved in a user call to \verb|CGConnect()|. After setting the
masks for the connection generator to tell it which neurons are local
and which are remote, the NEST kernel iteratively calls \verb|next()|.
This function returns source and target indices and parameter values
for the connection or NULL, if there are no connections anymore. The
connections are established one by one by calling NEST's basic
\verb|Network::connect()| function.

%----------------------------------------------------------------------

\section{Using connection generators in PyNN}\label{sec:conn_gen_pynn}

PyNN \citep[\url{http://www.neuralensemble.org/PyNN};][]{Davison09} is
a community driven effort to provide a simulator-independent API for
describing neuronal networks in Python. Given a PyNN/Python model
description, the user can choose which simulator to use without a need
for changes to the model script. This is achieved through a set of
\emph{simulator backends} which may be part of the PyNN code base or
distributed separately. A backend adapts PyNN to a specific simulator.

In PyNN, a neuronal network is built from \verb|Population|s of
neurons and \verb|Projection|s between them. Each \verb|Projection| is
created by a \verb|Connector|, which knows how to set up the individual
connections. Different \verb|Connector|s exist and allow to set up a variety
of different connection patterns.

Since version 0.7, PyNN has provided the generic \verb|CSAConnector|,
which can iterate a CSA connection set and issue one by one connect
calls to the different backends. Internally, the connector executes
the following two steps:

\begin{enumerate}
\item Form a finite connection-set adapted to the actual sizes of the
  populations by intersecting the given connection set with the
  Cartesian product of the neuron indices of the pre- and
  post-synaptic populations.
\item Connect the neurons. The weight, delay and any other synaptic
  parameters are taken from the connection set, if supplied as value
  sets (see Section~\ref{sec:csa}), and from the parameterization of
  the synapse type otherwise.
\end{enumerate}

However, one of the regular problems with this approach is that PyNN
needs to break up the compact high-level description of connectivity
given by users into the commands understood by the respective
backend. These are often already too low-level (e.g. convergent or
divergent connects, one-to-one connects) and thus entail a certain
performance penalty due to data transfer and function call overhead.

The problem of excessive data transfers between PyNN and the simulator
can be solved by passing a high-level description of connectivity to
the simulator. This representation can be iterated and expanded at the
simulator level and thus avoid overhead. Moreover, this allows
efficient parallelization at the lower software layers.
During this study, we extended the NEST backend for PyNN with a new
and specialized \verb|CSAConnector| which passes the complete
connection generator object down to the simulator (by calling PyNEST's
\verb|CGConnect()| function). The iteration over the connections can
then take place in NEST (see Section~\ref{sec:conn_gen_nest}). This
greatly reduces the overhead and thus improves the runtime and
scalability of connection generation (Section~\ref{sec:benchmarks}).

%----------------------------------------------------------------------

\section{Benchmarks}\label{sec:benchmarks}

We ran a series of benchmarks in order to assess the performance of
and compare two implementations of CSA (see Section~\ref{sec:impl})
and the two implementations of the \verb|CSAConnector| for PyNN (see Section
\ref{sec:conn_gen_pynn}). Grouped by the software layer on which the
iteration of the connection generator happens (either in Python by PyNN
or in C++ by NEST) and the CSA implementation used (\verb|csa| is the Python
version, \verb|libcsa| the C++ version), the following scenarios were
measured:

\begin{itemize}
\item \textbf{Python, csa} used PyNN's original \verb|CSAConnector|
  that is available for all backends in combination with the Python
  CSA implementation. The \verb|CSAConnector| intersects the
  \verb|csa| object with a mask representing the actual source and
  target nodes available and iterates the \verb|csa| object entirely
  at the Python level. It connects the neurons by issuing
  \verb|ConvergentConnect()| calls to PyNEST.
\item \textbf{C++, csa} used the new \verb|CSAConnector| for PyNN's NEST
  backend, which is available in the development version of PyNN, and the
  Python CSA implementation. The \verb|csa| object is passed down to NEST
  through \verb|CGConnect()|. The ConnectionGeneratorModule then
  iterates it at the C++ level by repeatedly calling the Python level
  iterator.
\item \textbf{Python, libcsa} used the generic \verb|CSAConnector| in
  PyNN and the C++ CSA implementation \verb|libcsa|. The
  \verb|CSAConnector| iterates the \verb|libcsa| object at the Python
  level, repeatedly calling its C++ connection generator.
\item \textbf{C++, libcsa} used the new \verb|CSAConnector| for PyNN's
  NEST backend and the C++ CSA implementation \verb|libcsa|. The
  \verb|libcsa| object is passed down to NEST through
  \verb|CGConnect()|. All iteration happen in C++ in the
  ConnectionGeneratorModule.
\end{itemize}

\ifdefined\INLINEFIGS
\begin{figure}[ht]
\centering
\includegraphics[scale=.7]{benchmarks/CSAConnector.pdf}
\caption{Benchmark results for the use of CSA in NEST through PyNN,
  comparing the two \texttt{CSAConnector} implementations explained in
  Section~\ref{sec:conn_gen_pynn} and two of the CSA implementations
  mentioned in Section~\ref{sec:csa}. Color and dash codes are given
  in the legends. Slope is the ratio of logarithms of the last and
  first data point shown. Pale lines denote the expected
  scaling. \textbf{A} shows the run time for connecting a network
  using CSAs \emph{random} mask with a probability of 0.1 for
  different numbers of neurons. This connector creates $O(n^2)$
  connections for $n$ neurons. The expected slope is thus
  2. \textbf{B} shows the same as in A, but using CSAs \emph{oneToOne}
  mask, which creates $O(n)$ connections for $n$ neurons and has an
  expected slope of 1. \textbf{C} shows a strong scaling experiment,
  wiring a network of 48,000 neurons using CSAs \emph{random} mask
  with a probability of 0.1 and varying the number of MPI processes
  from 1 to 48. The expected slope is -1, meaning that the run time
  drops linearly with the number of processes. \textbf{D} shows the
  results of a weak scaling experiment, increasing the number of
  connections by approx. $4.8 \cdot 10^6$ per additional MPI process
  for 1 to 48 processes. The expected slope is 0, as the load
  increases linearly with the number of
  processes.}\label{fig:pynn_benchmarks}
\end{figure}
\fi

The population size benchmarks (\Figure{4}{fig:pynn_benchmarks}A and
B) used one MPI process and varied the number of neurons from $10^2$
to $10^5$ with about one sample per order of magnitude. All tested
implementations of CSA (\verb|csa|, \verb|libcsa|) scale excellently
with slopes around 2 for the \emph{random} mask, independently of the
software layer (C++ or Python), on which the iteration was carried
out. However, in \Figure{4}{fig:pynn_benchmarks}, the vertical offsets
and the increasing slopes of the curves for the generic
\verb|CSAConnector| which iterates at the Python/PyNN level suggest
that the current implementation of this connector together with calls
through different software layers to setup individual connections adds
a significant overhead to the process of connection generation.

To demonstrate the scalability of the implementations, we carried out
both strong and weak scaling benchmarks, using CSA's \emph{random}
mask with a probability of $0.1$ (\Figure{4}{fig:pynn_benchmarks}C
and D). For each of them, the number of MPI processes was varied from
1 to 48.

In the strong scaling benchmark (\Figure{4}{fig:pynn_benchmarks}C),
the number of MPI processes was varied while keeping the total number
of neurons in the network fixed at $48000$. This resulted in
approx. 230 million connections being created. It is easily visible
that iteration of the CSA object at the Python level in the current
PyNN implementation of the original \verb|CSAConnector| is detrimental
to the scalability. In contrast, it is possible to obtain perfect
scaling if the iteration of the CSA object is carried out from the C++
layer. Using the C++ implementation of CSA, it is, however, possible
to gain another order of magnitude compared to the Python version.

During the weak scaling benchmark (\Figure{4}{fig:pynn_benchmarks}C),
the number of MPI processes was varied while the work load was
increased by a fixed number of connections per additional process.
The number of connections grows quadratically with the number of
neurons when using CSA's \emph{random} mask with a fixed
probality. The number of neurons per process was thus increased with
the square root of the desired number of connections. In the realm of
natural numbers, this leads to a slight error, which was, however,
well acceptable with values between $-1.42$\permil and $+1.08$\permil.

\subsection{Comparison to native interfaces}

To compare the performance of the \verb|ConnectionGenerator| interface
to more traditional ways of setting up connectivity, we also performed
performance and scaling benchmarks of the native interfaces for random
connectivity in PyNN and NEST. \Figure{5}{fig:native_benchmarks}
contrasts CSA's \emph{random} mask with a probability of $0.1$ with
PyNN's \verb|FixedProbailityConnector| (FPC) and NEST's function
\verb|RandomConvergentConnect| (RCC).

Please note that NEST does not provide a Bernoulli trial based
connection scheme such as used by FPC in PyNN and the \emph{random}
mask in CSA and RCC was chosen because it is the closest function to
resemble such a method. The use of RCC results, however, in a bias
towards the other methods over NEST, as it requires iterative calls to
RCC from the Python level, which entail a certain overhead in SLI,
PyNEST and the C++ implementation of RCC itself (data not shown).

\ifdefined\INLINEFIGS
\begin{figure}[ht]
\centering
\includegraphics[scale=.7]{benchmarks/native_routines.pdf}
\caption{Benchmark results comparing the use of CSA in NEST through
  PyNN and the native interfaces for random connectivity in PyNN and
  NEST. Color and dash codes are given in the legends. Slope is the
  ratio of logarithms of the last and first data point shown. Pale
  lines denote the expected scaling. \emph{PyNN.FCC} corresponds to
  PyNN's \texttt{FixedProbailityConnector}, \emph{nest.RCC} to NEST's
  function \texttt{RandomConvergentConnect}. \textbf{A} shows the run
  time for connecting a network of different numbers of neurons. The
  number of connections scales with $O(n^2)$ for $n$ neurons. The
  expected slope is thus 2. The data for libcsa is the same as shown
  in \Figure{4}{fig:pynn_benchmarks}A. \textbf{B} shows a strong
  scaling experiment, wiring a network of 48,000 neurons using CSAs
  \emph{random} mask with a probability of 0.1 and the corresponding
  native functions of PyNN and NEST. The experiment varies the number
  of MPI processes from 1 to 48. The expected slope is -1, meaning
  that the run time drops linearly with the number of processes. The
  data for libcsa is the same as shown in
  \Figure{4}{fig:pynn_benchmarks}C.}\label{fig:native_benchmarks}
\end{figure}
\fi

The run time benchmark (\Figure{5}{fig:native_benchmarks}A) again used
one MPI process and varied the number of neurons from $10^2$ to $10^5$
with about one sample per order of magnitude. It shows that all tested
variants for setting up the connectivity scale equally well with
slopes sloghtly below 2. The offset between NEST's RCC (written in
C++, but called repeatedly from Python) to the CSA object iterated in
C++ can be attributed to overhead in the additional software layers.

As in (\Figure{4}{fig:pynn_benchmarks}C, the comparative strong
scaling benchmark shown in \Figure{5}{fig:native_benchmarks}B varied
the number of MPI processes while keeping the total number of neurons
in the network fixed at $48000$, resulting in a total of approx. 230
million connections being created. The results are consistent with the
data from \Figure{4}{fig:pynn_benchmarks}C in that scalability is
destroyed if additional interpreted software layers are involved and
that an iteration in C++ is favorable. The effect is even stronger for
RCC, because its use to create a number of connections corresponding
to that yielded by a Bernoulli trial scheme entails even more
iterations through the additional software layers.

\subsection{Benchmark environment}

The machine used for benchmarking was equipped with 4 12-core AMD
Operon 6174 (Magny Cours) processors, organized into 8 NUMA domains
with 6 cores each. Other than the choice of the number of MPI
processes in a NUMA-friendly way, no measures (like pinning of
processes to cores, altering the affinity of threads to cores, etc.)
were taken to avoid distortions of the results. Users are, however,
free to benefit from such techniques to improve the performance of
their simulations.

\subsection{Software versions and benchmark scripts}

All benchmarks were using csa revision 119, libcsa from an internal
git repository (git@wand.pdc.kth.se:libcsa.git, version 3ef2db519a),
the development version of PyNN from
https://github.com/NeuralEnsemble/PyNN/ (version db76c748cd) and NEST
revision r10722 from the internal Subversion repository. The full
sources of the paper, the benchmark scripts and all data we obtained
is available from \url{https://github.com/mdjurfeldt/pns2csa}.

%----------------------------------------------------------------------

\section{Discussion and outlook}

We have demonstrated a novel way for a simulator to use code in an
external software library for specifying connectivity in a neuronal
network simulation.  Simulator and library are connected through a
generic interface, the \verb|ConnectionGenerator| interface, which
supports dynamic loading of connection generators without the need for
recompilation.  Benchmarks show good scaling when using it in NEST and
PyNN. The availability of this and associated interfaces lets users
flexibly choose a connection generating library independently of the
simulator used, and thereby grants greater freedom for describing
models.

The first version of the interface presented here was intentionally
made simple, as a proof of concept, and there are several possible
directions of development for its functionality. Currently, parameters
are passed as \verb|double|s. This could be generalized to other data
types.  For parallel simulators, connection generators may need access
to the MPI communicator.  Instead of using a fixed iteration order,
the order could be specified by the simulator. Iteration order could
also be unspecified, giving opportunities for more optimal iteration
on the part of the connection generating library.  In order to
maintain backward compatibility as new revisions of the interface are
developed, interface versioning could be introduced.

One arbitrary limitation in the current implementations of the NEST
ConnectionGeneratorModule and the PyNN \verb|CSAConnector| is that
value sets for the connection generator can only be used if its arity
is 0 or 2. This means that only values for weight and delay can be
generated by the connection generating library. For many synapse
models it would be beneficial to also set other parameters based on
rules in the connection generator. Examples of such synapse models are
STDP or short-term facilitation and depression.

At the moment, \verb|libneurosim| only contains the
\verb|ConnectionGenerator| interface and some auxilliary code. For the
future, we are planning to turn this into a community based effort to
share common interfaces and make it a generally useful library also
for the developers of other simulators than PyNN and NEST.

The differences in run time and scalability between an iteration of
the connection description in Python on the one side and the CSA
object iterated on the C++ level on the other suggests that a compact
description of connectivity iterated solely on the level of the
simulator indeed has a huge impact. NEST and other simulators can thus
greatly benefit from the availability of compact desctiptions such as
enabled by the \verb|ConnectionGenerator| interface

%----------------------------------------------------------------------

\section*{Conflict-of-Interest Statement}
The authors declare that the research was conducted in the absence of
any commercial or financial relationships that could be construed as a
potential conflict of interest.

\section*{Acknowledgement}
This work was partially done under the INCF Multiscale Modeling
Program. It is partially supported by the Helmholtz Association: HASB
and portfolio theme SMHB, the Jülich Aachen Research Alliance (JARA),
the VSR computation time grant JINB33 on the JUQUEEN supercomputer in
Jülich, and EU Grant 269921 (BrainScaleS). The authors would like to
thank Randall Munroe of \url{http://www.xkcd.org} for granting the
permission to use one of his drawings in
Figure~\ref{fig:sequence_diagram_nest}.

\bibliographystyle{frontiersinSCNS&ENG}
\bibliography{pns2csa13}

\end{document}
